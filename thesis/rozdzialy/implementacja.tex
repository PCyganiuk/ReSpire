\chapter{Implementacja aplikacji ReSpire}

Projekt: Aplikacja została zaprojektowana z myślą o prostocie i intuicyjności użytkowania. 
Projekt w Figmie

\section{Technologie}
Aplikacja została napisana w jęzku Dart we frameworku Flutter.

\section{Schemat plików/klas/modułów \Hania\ \Ola\ \Jakub\ \Karol}
Aplikacja ReSpire charakteryzuje się modułową budową, na którą składają się łącznie 63 pliki źródłowe w języku Dart. Projekt obejmuje 80 klas oraz ponad 400 metod realizujących logikę biznesową i interfejs użytkownika. Całkowity rozmiar projektu wynosi nieco ponad 10 kLOC (ang. Kilo Lines of Code – tysięcy linii kodu), z czego blisko 8900 stanowi tzw. czysty kod, określany jako SLOC (ang. Source Lines of Code). Ze względu na taką złożoność struktury, diagramy klas i architektury zostały w niniejszej dokumentacji podzielone na logiczne fragmenty, aby zachować ich czytelność.

\subsection{Klasy treningu} \label{subsec:training_classes}

Na trening składa się 12 klas, z czego główną z nich jest \texttt{Training}. Zawiera ona główne informacje o ćwiczeniu takie jak tytuł, czy opis, a także listę etapów, dźwięki i ustawienia. Struktura dźwięków została opisana w rodziale \ref{sec:Sounds}. 

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramy/class_diagram.png}
  \caption{Diagram klas treningu}
\end{figure}


\section{Edycja treningu \Ola}
\subsection{Menu - trening}
\subsection{Menu - dźwięki}
\subsection{Menu - inne}

\section{Przebieg treningu \Hania}
\subsection{Klasa TrainingParser}\label{subsec:TrainingParser}
Klasa \texttt{TrainingParser} powstała w celu przekształcenia hierarchicznych danych treningowych pobranych z lokalnej bazy danych Hive w ciąg występujących po sobie faz, oparty na skonfigurowanym uprzednio przez użytkownika wzorcu oddychania. Jej zadaniem jest zwracanie kolejnych faz do obiektu \texttt{TrainingController}. Dzięki temu logika przełączania faz i powtórzeń jest odseparowana od interfejsu. 

Konstruktor jako parametr przyjmuje obiekt klasy \texttt{Training} i zapisuje do zmiennej \textit{currentTrainingStage} pierwszy etap treningu. Fragment realizujący tą funkcjonalność przedstawiono poniżej w kodzie \ref{code/parser/constructor}.

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={TrainingParser - konstruktor}, label={code/parser/constructor}]
  Training training;
  TrainingStage currentTrainingStage;
  late breathing_phase.BreathingPhase currentBreathingPhase;

  TrainingParser({required this.training})
      : currentTrainingStage = training.trainingStages[0];
\end{lstlisting}
\end{figure}

\newpage
Zadaniem funkcji \texttt{nextInstruction}, przedstawionej na kodzie \ref{code/parser/nextInstruction}, jest zwrócenie danych dotyczącej kolejnej fazy oddechowej w postaci mapy \texttt{Map<String, dynamic>} lub wartości \texttt{null} w~przypadku zakończenia całego treningu. 

W pierwszej kolejności analizowany jest aktualny indeks fazy oddechowej (\textit{breathingPhaseID}). Jeżeli wskazuje on ostatnią fazę w bieżącym etapie, oznacza to zakończenie jednego pełnego cyklu etapu. W takim przypadku indeks fazy jest zerowany (\textit{breathingPhaseID = 0}), a licznik wykonanych powtórzeń w etapie (\textit{doneReps}) zwiększany jest o jeden. Następnie sprawdzana jest liczba wykonanych powtórzeń w odniesieniu do wartości zdefiniowanej w obiekcie etapu (\textit{currentTrainingStage.reps}). W przypadku jej osiągnięcia następuje przejście do kolejnego etapu treningu poprzez inkrementację indeksu \textit{trainingStageID}. Jeżeli po tej operacji indeks ten osiągnie wartość równą liczbie wszystkich etapów w strukturze treningu, funkcja zwraca \textit{null}, sygnalizując zakończenie sesji. W przeciwnym razie wczytywany jest nowy etap (\textit{currentTrainingStage = training.trainingStages[trainingStageID]}), a licznik \textit{doneReps} zostaje zresetowany do zera. Gdy aktualna faza nie była ostatnią w cyklu, indeks \textit{breathingPhaseID} jest jedynie zwiększany o jeden. Po ustaleniu poprawnego indeksu do zmiennej \textit{currentBreathingPhase} przypisywana jest odpowiadająca mu faza oddechowa. Kolejnym etapem jest obliczenie rzeczywistego czasu trwania fazy z uwzględnieniem mechanizmu progresji. 

Na podstawie obliczonego czasu tworzona jest zmienna \textit{progressedBreathingPhase}, w której pole \textit{duration} przyjmuje wartość \textit{durationSeconds}, natomiast pozostałe atrybuty (\textit{breathingPhaseType}, \textit{breathType}, \textit{breathDepth}, \textit{sounds}) są kopiowane z obecnej fazy oddechowej.

Funkcja zwraca mapę zawierającą następujące klucze:
\begin{itemize}
    \item \textit{breathingPhase} - pełny obiekt fazy,
    \item \textit{remainingTime} - czas trwania fazy wyrażony w milisekundach,
    \item \textit{trainingStageName} - nazwę aktualnego etapu treningu.
\end{itemize}

W ten sposób \textit{nextInstruction()} pełni rolę centralnego mechanizmu sterującego przebiegiem treningu oddechowego, zapewniając poprawne przechodzenie pomiędzy fazami i etapami oraz automatyczne zwiększanie trudności zgodnie z zaimplementowanym modelem progresji liniowej.

\newpage
\begin{figure}[h]
\centering
\begin{lstlisting}[caption={TrainingParser - pobranie instrukcji}, label={code/parser/nextInstruction}]
  Map<String, dynamic>? nextInstruction() {
    if (breathingPhaseID == currentTrainingStage.breathingPhases.length - 1) {
      breathingPhaseID = 0;
      doneReps++;

      if (doneReps == currentTrainingStage.reps) {
        trainingStageID++;
        if (trainingStageID == training.trainingStages.length) {
          return null;
        } else {
          currentTrainingStage = training.trainingStages[trainingStageID];
          doneReps = 0;
        }
      }
    } else {
      breathingPhaseID++;
    }

    currentBreathingPhase = currentTrainingStage.breathingPhases[breathingPhaseID];

    double durationSeconds = currentBreathingPhase.duration + (currentTrainingStage.increment * doneReps);

    final progressedBreathingPhase = breathing_phase.BreathingPhase(
      duration: durationSeconds,
      breathingPhaseType: currentBreathingPhase.breathingPhaseType,
      breathType: currentBreathingPhase.breathType,
      breathDepth: currentBreathingPhase.breathDepth,
      sounds: currentBreathingPhase.sounds,
    );

    return {
      "breathingPhase": progressedBreathingPhase,
      "remainingTime": (durationSeconds * 1000).truncate(),
      "trainingStageName": currentTrainingStage.name,
    };
  }
\end{lstlisting}
\end{figure}

\subsection{TrainingController} \label{subsec:TrainingController}
\subsection{AnimatedCircle} \label{subsec:AnimatedCircle}
Komponent \texttt{AnimatedCircle} odpowiada za wizualizację przebiegu fazy oddechowej w postaci animowanego koła. Wdech powoduje zwiększanie jego promienia, wydech - zmniejszanie, natomiast fazy retencji i regeneracji utrzymują stały rozmiar.

Obiekt przyjmuje dwa parametry - obiekt typu \texttt{BreathingPhase?}, który reprezentuje aktualną fazę oddechową bądź wartość null w przypadku zakończenia treningu oraz obiekt typu \texttt{bool} \textit{isPaused}, reprezentujący stan wstrzymania treningu. Framgment tworzenia klasy przedstawiony został w kodzie \ref{code/circle/constructor}.

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={AnimatedCircle - konstruktor}, label={code/circle/constructor}]
  final breathing_phase.BreathingPhase? breathingPhase;
  final bool isPaused;

  const AnimatedCircle({super.key, required this.breathingPhase, required this.isPaused});
\end{lstlisting}
\end{figure}

Po utworzeniu obiektu na początku zostaje obliczona wartość początkowa czasu trwania animacji, która zapisywana jest w zmiennej \textit{duration} na podstawie czasu trwania danej fazy. Następnie inicjowany jest kontroler animacji \textit{controller} oraz animacja zmiany promienia koła \textit{circleAnimation}. Kontrolwe ustawiany jest na stan początkowy (\textit{controller.value=0.0}). Jeżeli trening nie jest wstrzymany i dostępna jest faza oddechowa, uruchamiana jest odpowiednia animacja - rosnąca dla wdechu lub malejąca dla wydechu. Fragment funkcji init przedstawiono w kodzie \ref{code/circle/init}.

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={AnimatedCircle - fragment funkcji init}, label={code/circle/init}]
  @override
  void initState() {
    super.initState();

    duration = widget.breathingPhase == null ? 0 : (widget.breathingPhase!.duration * 1000).toInt();

    _controller = AnimationController(
      duration: Duration(milliseconds: duration),
      vsync: this,
    );

    _circleAnimation = Tween<double>(begin: 125.0, end: 300.0).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
    _controller.duration = Duration(milliseconds: duration);

    _controller.value = 0.0;

    if (!widget.isPaused && widget.breathingPhase != null) {
      if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.inhale) {
        _controller.forward(from: 0.0);
      } else if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.exhale) {
        _controller.reverse(from: 1.0);
      }
    }
  }
\end{lstlisting}
\end{figure}

Zachowanie koła zależne jest od jego poprzedniego stanu i zmiany parametrów wejściowych. Jeżeli faza oddechowa sie zmieniła względem ostatniego stanu następuje reakcja zmiany animacji. Ponownie obliczany jest czas trwania animacji (zmienna \textit{duration}) i ustawiane zostaje poprawne zachowanie - wzrost promienia dla wdechu i jego zmniejszenie dla wydechu. Aktualizację stanu przedstawiono w kodzie \ref{code/circle/update}

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={AnimatedCircle - aktualizacja stanu}, label={code/circle/update}]
    if (widget.breathingPhase != oldWidget.breathingPhase && widget.breathingPhase != null) {
      log("${widget.breathingPhase?.breathingPhaseType.name}");

      duration = widget.breathingPhase == null ? 0 : (widget.breathingPhase!.duration * 1000).toInt();
      _controller.duration = Duration(milliseconds: duration);

      if (!widget.isPaused && widget.breathingPhase != null) {
        if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.inhale) {
          _controller.forward(from: 0.0);
        } else if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.exhale) {
          _controller.reverse(from: 1.0);
        }
      } else {
        _controller.stop();
      }
    }
\end{lstlisting}
\end{figure}

Koło \texttt{AnimatedCircle} reaguje również na zmianę parametru \textit{isPaused}, która określa czy trening został zatrzymany. Jeśli tak, animacja zostaje wstrzymana, w innym wypadku jeśli trening był zatrzymany i zostawł wznowiony, animacja zostaje kontynuowana w kierunku wynikającym z~bieżącej fazy. Fragment ten przedstawiono w kodzie \ref{code/circle/pause}.

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={AnimatedCircle - reakcja na pauzę i wznowienie}, label={code/circle/pause}]
if (widget.isPaused && !oldWidget.isPaused) {
      _controller.stop();
    } else if (!widget.isPaused && oldWidget.isPaused) {
      if (widget.breathingPhase != null) {
        if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.inhale) {
          _controller.forward();
        } else if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.exhale) {
          _controller.reverse();
        }
      }
    }
\end{lstlisting}
\end{figure}


Dodatkowo utworzony został obiekt łączący \texttt{AnimatedCircle} oraz dwa koła statyczne typu \texttt{Container} wizualizujące maksymalną i minimalną wartość promiania koła \texttt{AnimatedCircle}, by umożliwić użytkownikowi lepiej ocenić przebieg wdechu i wydechu.

\subsection{Instrukcja}

\section{Dźwięki \Jakub} \label{sec:Sounds}

Wysoki stopień konfigurowalności warstwy audio przez użytkownika wymusił dekompozycję logiki biznesowej aplikacji na klasy odpowiedzialne za poszczególne przypadki użycia, postępując zgodnie z zasadą pojedynczej odpowiedzialności. 


\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagramy/soundManagers_diagram.png}
  \caption{Diagram klas dźwiękowych}
\end{figure}

\subsection{SoundManager} \label{subsec:SoundManager}
Centralnym elementem modułu audio jest klasa \texttt{SoundManager}. Ze względu na konieczność zapewnienia globalnego punktu dostępu do listy załadowanych plików oraz potrzebę współdzielenia jednej instancji obiektu przez wiele komponentów aplikacji, zastosowano w niej wzorzec projektowy Singleton. W polach wspomnianej instancji przechowywane są listy dźwięków krótkich, jak i długich. Rozróżnienie na typy dźwięków było niezbędne ze względu na odmienne ładowanie i odtwarzanie plików. Krótkie efekty dźwiękowe wymagają minimalnej latencji (czasu reakcji) przy odtwarzaniu, natomiast długie ścieżki dźwiękowe, charakteryzujące się rzadszą rotacją i mniejszą dynamiką zmian, nie podlegają tak rygorystycznym wymogom czasowym przy inicjalizacji. Do osiągnięcia tego wymagania należało zastosować oddzielne konfiguracje odtwarzaczy dźwięków (komponentów klasy \texttt{AudioPlayer}) — low latency mode (tryb minimalnego czasu reakcji) lub media player mode (tryb odtwarzania media). Mimo zastosowania tych trybów wysoki narzut obliczeniowy związany z  częstą inicjalizacją odtwarzaczy uniemożliwił odtwarzanie sygnałów dźwiękowych z wymaganą precyzją. Ograniczenie to zmusiło nas do wprowadzenia mechanizmu puli obiektów — \texttt{AudioPlayerPool} \ref{subsec:AudioPlayerPool}.

 \todoJakub{Rozpisz poniższe}
- fade in/out
- ustawienie by dźwięki mogły lecieć razem

\subsection{SingleSoundManager} \label{subsec:SingleSoundManager}
\subsection{PlaylistManager} \label{subsec:PlaylistManager}
\subsection{AudioPlayerPool} \label{subsec:AudioPlayerPool}
\subsection{textToSpeech} \label{subsec:TTS}

\section{Języki} \label{sec:Languages}

\section{Baza danych}

\section{Import i export \Karol} \label{sec:Import}







