\chapter{Implementacja aplikacji ReSpire}

Projekt: Aplikacja została zaprojektowana z myślą o prostocie i intuicyjności użytkowania. 
Projekt w Figmie

\section{Technologie}
Technologie:
Aplikacja została napisana w jęzku Dart we frameworku Flutter. 
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus elementum arcu nec blandit aliquam. Integer eros dolor, molestie eget dictum quis, luctus sit amet sapien. Proin dignissim felis in ornare volutpat. Morbi vulputate rutrum efficitur. Ut vehicula vehicula metus, et iaculis tortor mattis vel. Nam blandit, arcu quis ultricies blandit, libero ante commodo augue, in accumsan dui leo at orci. Phasellus in augue et velit pulvinar malesuada ut et sem. Nulla vehicula nibh eu odio sollicitudin sagittis. Praesent condimentum semper neque, tincidunt luctus nisl scelerisque sed. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.

\section{Schemat plików/klas/modułów \Hania\ \Ola\ \Jakub\ \Karol}

\section{Podział prac w zespole \Jakub}
\section{Edycja treningu \Ola}
\subsection{Menu - trening}
\subsection{Menu - dźwięki}
\subsection{Menu - inne}

\section{Przebieg treningu \Hania}
\subsection{Klasa TrainingParser}
Klasa \texttt{TrainingParser} powstała w celu przekształcenia hierarchicznych danych treningowych pobranych z lokalnej bazy danych Hive w ciąg występujących po sobie faz, oparty na skonfigurowanym uprzednio przez użytkownika wzorcu oddychania. Jej zadaniem jest zwracanie kolejnych faz do obiektu \texttt{TrainingController}. Dzięki temu logika przełączania faz i powtórzeń jest odseparowana od interfejsu. 

Konstruktor jako parametr przyjmuje obiekt klasy \texttt{Training} i zapisuje do zmiennej \textit{currentTrainingStage} pierwszy etap treningu. Fragment realizujący tą funkcjonalność przedstawiono poniżej w kodzie \ref{code/parser/constructor}.

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={TrainingParser - konstruktor}, label={code/parser/constructor}]
  Training training;
  TrainingStage currentTrainingStage;
  late breathing_phase.BreathingPhase currentBreathingPhase;

  TrainingParser({required this.training})
      : currentTrainingStage = training.trainingStages[0];
\end{lstlisting}
\end{figure}

\newpage
Zadaniem funkcji \texttt{nextInstruction}, przedstawionej na kodzie \ref{code/parser/nextInstruction}, jest zwrócenie danych dotyczącej kolejnej fazy oddechowej w postaci mapy \texttt{Map<String, dynamic>} lub wartości \texttt{null} w~przypadku zakończenia całego treningu. 

W pierwszej kolejności analizowany jest aktualny indeks fazy oddechowej (\textit{breathingPhaseID}). Jeżeli wskazuje on ostatnią fazę w bieżącym etapie, oznacza to zakończenie jednego pełnego cyklu etapu. W takim przypadku indeks fazy jest zerowany (\textit{breathingPhaseID = 0}), a licznik wykonanych powtórzeń w etapie (\textit{doneReps}) zwiększany jest o jeden. Następnie sprawdzana jest liczba wykonanych powtórzeń w odniesieniu do wartości zdefiniowanej w obiekcie etapu (\textit{currentTrainingStage.reps}). W przypadku jej osiągnięcia następuje przejście do kolejnego etapu treningu poprzez inkrementację indeksu \textit{trainingStageID}. Jeżeli po tej operacji indeks ten osiągnie wartość równą liczbie wszystkich etapów w strukturze treningu, funkcja zwraca \textit{null}, sygnalizując zakończenie sesji. W przeciwnym razie wczytywany jest nowy etap (\textit{currentTrainingStage = training.trainingStages[trainingStageID]}), a licznik \textit{doneReps} zostaje zresetowany do zera. Gdy aktualna faza nie była ostatnią w cyklu, indeks \textit{breathingPhaseID} jest jedynie zwiększany o jeden. Po ustaleniu poprawnego indeksu do zmiennej \textit{currentBreathingPhase} przypisywana jest odpowiadająca mu faza oddechowa. Kolejnym etapem jest obliczenie rzeczywistego czasu trwania fazy z uwzględnieniem mechanizmu progresji. 

Na podstawie obliczonego czasu tworzona jest zmienna \textit{progressedBreathingPhase}, w której pole \textit{duration} przyjmuje wartość \textit{durationSeconds}, natomiast pozostałe atrybuty (\textit{breathingPhaseType}, \textit{breathType}, \textit{breathDepth}, \textit{sounds}) są kopiowane z obecnej fazy oddechowej.

Funkcja zwraca mapę zawierającą następujące klucze:
\begin{itemize}
    \item \textit{breathingPhase} - pełny obiekt fazy,
    \item \textit{remainingTime} - czas trwania fazy wyrażony w milisekundach,
    \item \textit{trainingStageName} - nazwę aktualnego etapu treningu.
\end{itemize}

W ten sposób \textit{nextInstruction()} pełni rolę centralnego mechanizmu sterującego przebiegiem treningu oddechowego, zapewniając poprawne przechodzenie pomiędzy fazami i etapami oraz automatyczne zwiększanie trudności zgodnie z zaimplementowanym modelem progresji liniowej.

\newpage
\begin{figure}[h]
\centering
\begin{lstlisting}[caption={TrainingParser - pobranie instrukcji}, label={code/parser/nextInstruction}]
  Map<String, dynamic>? nextInstruction() {
    if (breathingPhaseID == currentTrainingStage.breathingPhases.length - 1) {
      breathingPhaseID = 0;
      doneReps++;

      if (doneReps == currentTrainingStage.reps) {
        trainingStageID++;
        if (trainingStageID == training.trainingStages.length) {
          return null;
        } else {
          currentTrainingStage = training.trainingStages[trainingStageID];
          doneReps = 0;
        }
      }
    } else {
      breathingPhaseID++;
    }

    currentBreathingPhase = currentTrainingStage.breathingPhases[breathingPhaseID];

    double durationSeconds = currentBreathingPhase.duration + (currentTrainingStage.increment * doneReps);

    final progressedBreathingPhase = breathing_phase.BreathingPhase(
      duration: durationSeconds,
      breathingPhaseType: currentBreathingPhase.breathingPhaseType,
      breathType: currentBreathingPhase.breathType,
      breathDepth: currentBreathingPhase.breathDepth,
      sounds: currentBreathingPhase.sounds,
    );

    return {
      "breathingPhase": progressedBreathingPhase,
      "remainingTime": (durationSeconds * 1000).truncate(),
      "trainingStageName": currentTrainingStage.name,
    };
  }
\end{lstlisting}
\end{figure}

\subsection{TrainingController}
\subsection{AnimatedCircle}
Komponent \texttt{AnimatedCircle} odpowiada za wizualizację przebiegu fazy oddechowej w postaci animowanego koła. Wdech powoduje zwiększanie jego promienia, wydech - zmniejszanie, natomiast fazy retencji i regeneracji utrzymują stały rozmiar.

Obiekt przyjmuje dwa parametry - obiekt typu \texttt{BreathingPhase?}, który reprezentuje aktualną fazę oddechową bądź wartość null w przypadku zakończenia treningu oraz obiekt typu \texttt{bool} \textit{isPaused}, reprezentujący stan wstrzymania treningu. Framgment tworzenia klasy przedstawiony został w kodzie \ref{code/circle/constructor}.

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={AnimatedCircle - konstruktor}, label={code/circle/constructor}]
  final breathing_phase.BreathingPhase? breathingPhase;
  final bool isPaused;

  const AnimatedCircle({super.key, required this.breathingPhase, required this.isPaused});
\end{lstlisting}
\end{figure}

Po utworzeniu obiektu na początku zostaje obliczona wartość początkowa czasu trwania animacji, która zapisywana jest w zmiennej \textit{duration} na podstawie czasu trwania danej fazy. Następnie inicjowany jest kontroler animacji \textit{controller} oraz animacja zmiany promienia koła \textit{circleAnimation}. Kontrolwe ustawiany jest na stan początkowy (\textit{controller.value=0.0}). Jeżeli trening nie jest wstrzymany i dostępna jest faza oddechowa, uruchamiana jest odpowiednia animacja - rosnąca dla wdechu lub malejąca dla wydechu. Fragment funkcji init przedstawiono w kodzie \ref{code/circle/init}.

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={AnimatedCircle - fragment funkcji init}, label={code/circle/init}]
  @override
  void initState() {
    super.initState();

    duration = widget.breathingPhase == null ? 0 : (widget.breathingPhase!.duration * 1000).toInt();

    _controller = AnimationController(
      duration: Duration(milliseconds: duration),
      vsync: this,
    );

    _circleAnimation = Tween<double>(begin: 125.0, end: 300.0).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
    _controller.duration = Duration(milliseconds: duration);

    _controller.value = 0.0;

    if (!widget.isPaused && widget.breathingPhase != null) {
      if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.inhale) {
        _controller.forward(from: 0.0);
      } else if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.exhale) {
        _controller.reverse(from: 1.0);
      }
    }
  }
\end{lstlisting}
\end{figure}

Zachowanie koła zależne jest od jego poprzedniego stanu i zmiany parametrów wejściowych. Jeżeli faza oddechowa sie zmieniła względem ostatniego stanu następuje reakcja zmiany animacji. Ponownie obliczany jest czas trwania animacji (zmienna \textit{duration}) i ustawiane zostaje poprawne zachowanie - wzrost promienia dla wdechu i jego zmniejszenie dla wydechu. Aktualizację stanu przedstawiono w kodzie \ref{code/circle/update}

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={AnimatedCircle - aktualizacja stanu}, label={code/circle/update}]
    if (widget.breathingPhase != oldWidget.breathingPhase && widget.breathingPhase != null) {
      log("${widget.breathingPhase?.breathingPhaseType.name}");

      duration = widget.breathingPhase == null ? 0 : (widget.breathingPhase!.duration * 1000).toInt();
      _controller.duration = Duration(milliseconds: duration);

      if (!widget.isPaused && widget.breathingPhase != null) {
        if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.inhale) {
          _controller.forward(from: 0.0);
        } else if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.exhale) {
          _controller.reverse(from: 1.0);
        }
      } else {
        _controller.stop();
      }
    }
\end{lstlisting}
\end{figure}

Koło \texttt{AnimatedCircle} reaguje również na zmianę parametru \textit{isPaused}, która określa czy trening został zatrzymany. Jeśli tak, animacja zostaje wstrzymana, w innym wypadku jeśli trening był zatrzymany i zostawł wznowiony, animacja zostaje kontynuowana w kierunku wynikającym z~bieżącej fazy. Fragment ten przedstawiono w kodzie \ref{code/circle/pause}.

\begin{figure}[h]
\centering
\begin{lstlisting}[caption={AnimatedCircle - reakcja na pauzę i wznowienie}, label={code/circle/pause}]
if (widget.isPaused && !oldWidget.isPaused) {
      _controller.stop();
    } else if (!widget.isPaused && oldWidget.isPaused) {
      if (widget.breathingPhase != null) {
        if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.inhale) {
          _controller.forward();
        } else if (widget.breathingPhase!.breathingPhaseType == breathing_phase.BreathingPhaseType.exhale) {
          _controller.reverse();
        }
      }
    }
\end{lstlisting}
\end{figure}

Dodatkowo utworzony został obiekt łączący \texttt{AnimatedCircle} oraz dwa koła statyczne typu \texttt{Container} wizualizujące maksymalną i minimalną wartość promienia koła \texttt{AnimatedCircle}, by umożliwić użytkownikowi lepiej ocenić przebieg wdechu i wydechu.

\subsection{InstructionSlider}
\texttt{InstructionSlider} to animowany komponent odpowiadający za wizualizację ciągu instrukcji dla użytkownika w postaci trzech kafelków reprezentujących:
\begin{itemize}
    \item poprzednią fazę oddechową,
    \item obecną fazę oddechową,
    \item nadchodzącą fazę oddechową.
\end{itemize}
Gdy zachodzi zmiana fazy, cała lista przesuwa się w lewo, a na końcu pojawia się nowy kafelek z~kolejną instrukcją.

Obiekt przyjmuje trzy parametry - \textit{preparationTime}, czyli czas trwania fazy przygotowania przed treningiem, kolejkę \textit{breathingPhasesQueue}, która jest ciągiem faz w treningu oraz \textit{change}, która jest wyznacznikiem zmiany obecnie trwającej fazy. Framgment tworzenia klasy przedstawiony został w kodzie \ref{code/slider/constructor}.

\begin{figure}[h] 
\centering
\begin{lstlisting}[caption={InstructionSlider - konstruktor}, label={code/slider/constructor}]
double preparationTime;
Queue<breathing_phase.BreathingPhase?> breathingPhasesQueue = Queue<breathing_phase.BreathingPhase?>();
int change; 

InstructionSlider({super.key,required this.preparationTime,  required this.breathingPhasesQueue, required this.change});
\end{lstlisting}
\end{figure}

Podczas inicjalizacji obiekt tworzy pierwszy kafelek reprezentujący fazę przygotowania. Następnie dodawane są w formie kafelków dwie fazy z kolejki faz treningu. Każdy kafelek przechowuje tekst w postaci instrukcji dla użytkowanika i informację, na której pozycji ma się znaleźć. Fragment dodawania obiektów przedstawiono w kodzie \ref{code/slider/init}.

\begin{figure}[h] 
\centering
\begin{lstlisting}[caption={InstructionSlider - fragment funkcji init}, label={code/slider/init}]
_blocks.add(
  InstructionBlock(
    text: translationProvider.getTranslation(
      "BreathingPage.InstructionSlider.get_ready_block_text") + "\n${widget.preparationTime} s", 
    position: 0.0)
);

addNewBreathingPhase(widget.breathingPhasesQueue.elementAt(1));
addNewBreathingPhase(widget.breathingPhasesQueue.elementAt(2));
\end{lstlisting}
\end{figure}

\texttt{InstructionSlider} korzysta z \texttt{AnimationController}, który przy każdej zmianie fazy przesuwa wszystkie kafelki o jedną pozycję w lewo. Każdy kafelek ma przypisaną pozycję z przedziału od -2 do 2. Wartości skrajne (-2 oraz 2) znajdują się poza obszarem widocznym dla użytkownika i służą jedynie do zapewnienia płynniejszej i estetczniejszej animacji. W centrum ekranu znajdują się trzy środkowe pozycje: -1 odpowiada fazie poprzedniej, 0 fazie bieżącej, a 1 fazie nadchodzącej. Gdy kafelek na pozycji -2 ma zostać przesunięty zostaje usunięty w celach optymalizacyjnych. Dokładną implementację animacji przedstawiono w~kodzie \ref{code/slider/animation}. Dodatkowo wykorzystywany jest mechanizm skalowania środkowego kafelka w celu wizualnego podkreślenia aktualnie trwającej fazy.

\begin{figure}[h] 
\centering
\begin{lstlisting}[caption={InstructionSlider - animacja}, label={code/slider/animation}]
_controller = AnimationController(vsync: this, duration: duration);
_animation = Tween<double>(begin: 0.0, end: -1.0).animate(
  CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
);
_controller.addStatusListener((status) {
  if (status == AnimationStatus.completed) {
    _controller.reset();
    setState(() {
      final removed = _blocks.where((b) => b.position <= -2).toList();
      _blocks.removeWhere((b) => b.position <= -2);
      _blocks.forEach((b) => b.position += _animation.value); 
      _blocks.forEach((b) => b.position -= 1);
    });
  }
});
\end{lstlisting}
\end{figure}

Każda zmiana fazy powoduje uruchomienie aktualizacji stanu komponentu. Mechanizm opiera się na porównaniu poprzedniej i bieżącej wartości parametru \textit{change}. Dzięki temu komponent wykrywa moment rozpoczęcia nowej fazy. Obliczany jest wtedy czas trwania nowej fazy, wywoływana jest animacja oraz dodawany nowy kafelek z instrukcją. Funkcję aktualizacji przedstawiono w kodzie \ref{code/slider/update}.

\begin{figure}[h] 
\centering
\begin{lstlisting}[caption={InstructionSlider - aktualizacja stanu}, label={code/slider/update}]
if(oldWidget.change != widget.change) {
  final int phaseDuration = (widget.breathingPhasesQueue.elementAt(0)?.duration.toInt() != null)
    ? (widget.breathingPhasesQueue.elementAt(0)!.duration * 1000).toInt() - 50 
    : 400;
  _controller.duration = Duration(milliseconds: min(phaseDuration,400));
  _controller.forward();
  if(_blocks.last.text!=translationProvider.getTranslation(
    "BreathingPage.InstructionSlider.ending_tile_text")) {
    addNewBreathingPhase(widget.breathingPhasesQueue.elementAt(2));
  }
}
\end{lstlisting}
\end{figure}

\section{Dźwięki \Jakub}
\subsection{SoundManager}
\subsection{textToSpeach}

\section{Języki}

\section{Baza danych}

\section{Import i export \Karol}







